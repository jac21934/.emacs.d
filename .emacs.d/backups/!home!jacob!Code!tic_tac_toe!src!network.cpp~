#include "network.h"
using namespace std;


void network::run(){

		string header = "DATA STATE ZEROES";
		
//		cout << header << endl;
		isUpState = false;
		depol_strength = 0;
		old_depol_strength=0;
    // prune(0.1);
    int counter = 0;
		num_fired = 0;
    for(int t = 0; t < max_turns; t++){
				network_fired = false;
				update_av();
				avalanche_neuron_noise();
				
				// if (network_fired == true){

				// 		// cout << num_fired << endl;
				// 		// num_fired = 0;
				// 		cout << counter << endl;x
				// 		counter = 0;
				// }
				// else{				      
				// 		counter++;
				// }


				// for(int i = 0; i < net_size; i++){
				// 		for(int j = 0; j < net_size;j++){

				// 				random_weight_increase();
				// 		}
				// }

				// if(t % 10000 == 0){
				//     prune(.1);
				// }
    }

}

double network::sum_neurons(){
    if(net_size <= 0){
				return 0;
    }
    else{
				double sum = 0;
				for(int i = 0; i < net_size; i++){
						sum += neuron[i];
				}
				return sum;
    }

}

double network::L1_norm(){
    if( net_size == 0){

				return 0;
    }

    else{
				double sum = 0;

				for(int i = 0; i< net_size; i++){
						for(int j = 0; j < net_size; j++){
								sum+= weight[i][j];
						}
				}

       
				return sum;

    }
}

double network::std_dev(){

    double ave = 0;
    double stddev = 0;
  
    for(int i = 0; i < net_size; i++){

				for(int j = 0; j < net_size; j++){
						ave += weight[i][j];
	    
				}
    }

    ave = ave/double(net_size*net_size);

    for(int i = 0; i < net_size; i++){

				for(int j = 0; j < net_size; j++){
						stddev+= (weight[i][j] - ave)*(weight[i][j] - ave);

				}
    }

    stddev = stddev/(net_size*net_size);
    stddev = sqrt(stddev);

    return stddev;



    return 0;
}

void network::prune(double threshold){

    for(int i = 0; i <net_size; i++){
				for(int j = 0; j < net_size; j++){

						if(weight[i][j] < threshold){

								weight[i][j] = 0;
						}
				}
    }
}

double network::ave_connectivity(){
    double ave_connectivity = 0;

    for(int i = 0; i < net_size; i++){
				for(int j = 0; j < net_size; j++){
	    
						if (weight[i][j] > 0){

								ave_connectivity+=1;
						}
				}
    }

    ave_connectivity = ave_connectivity/double(net_size * net_size);

    return ave_connectivity;
}

void network::transpose(){

    double ** weight_buff;

    if(net_size <= 0){
				return;
    }

    weight_buff = new double*[net_size];
    
    for(int i = 0; i < net_size; i++){
				weight_buff[i] = new double[net_size];
	
    }
    
    
    for(int i = 0; i < net_size; i++){
				for(int j = 0; j < net_size; j++){
						weight_buff[j][i] = weight[i][j];

				}
	
    }
    
    
    for(int i = 0; i < net_size; i++){
				for(int j = 0; j < net_size; j++){
						weight[i][j] = weight_buff[i][j];

				}
	
    }    
    
    
    
    for(int i = 0; i < net_size; i++){

				delete[] weight_buff[i];
	
    }

    delete[] weight_buff;
    
    
}

int network::bond_number(){

   	int num = 0;


    if(net_size <= 0){
				return num;
    }



    else{

				for(int i = 0; i < net_size; i++){
						for(int j = 0; j < net_size; j++){
								if( abs(weight[i][j]) > MIN_RES ){
										num++;
								}
						}
				}
    }

    return num;

}

// ************** TRIGGER FUNCTIONS ************************

inline double network::trigger_sigmoid( double input){
    return 1./double(1. + exp(-input) );
}
inline double network::trigger_sign( double input){
    if(input > 0.){
				return 1;
    }
    else if (input < 0){
				return -1;
    }
    else{
				return 0;
    }

}
inline double network::trigger_arctan( double input){

    return double(2*atan(input))/double(M_PI);
}

// ******************** Updating Neurons ******************

double network::neuron_state(int neuron_index, string funct){

    double buff = 0;

		if( funct == "SIGMOID"){

				for(int j = 0; j < net_size; j++){
						buff += weight[neuron_index][j] * neuron[j];
				}

				return trigger_sigmoid(buff);
		}



		else if( funct == "SIGN"){
				for(int j = 0; j < net_size; j++){
						//cout << "Neuron[" << j << "]:" << neuron[j] << " weight[" << neuron_index << "][" << j << "]: " << weight[neuron_index][j]  << endl;

						//cout  << "product: " << weight[neuron_index][j] *neuron[j] << endl;

						buff += weight[neuron_index][j] *neuron[j];

						//	cout << buff << " ";
				}
			
//		cout << "Before Sign:" << buff << endl;

				buff = trigger_sign(buff);
				//	cout <<": " << buff << endl;			

//		cout << "After Sign:" << buff << endl;

		}

		else if (funct == "ARCTAN"){
				for(int j = 0; j < net_size; j++){
		
						buff += weight[neuron_index][j] * neuron[j];
				}

				return trigger_arctan(buff);
		}

		else{
				cout << "IMPROPER TRIGGER FUNCTION SPECIFIED" << endl;
				return 0;

		}

		//buff /= double(net_size);

    return buff;

}

void network::update(string type){

    bool weight_noise = false;
    bool neuron_noise = false;

    double* neuron_buff = new double[net_size];
    
    double* weight_buff = new double[net_size];

    double learning_rate = 1;// 0.0001;
    
    //   for(int i = 0; i < net_size; i++){
//	neuron_buff[i] = neuron[i];

    //  }

    double buff;

    for(int i = 0; i < net_size; i++){
				buff = 0;
	
				for(int j = 0; j < net_size; j++){

						buff += weight[i][j] * neuron[j];
				}
//	cout << buff << endl;

				neuron_buff[i] = (2./M_PI)*atan((M_PI/2.)*buff);

				if(neuron_noise == true){
						neuron_buff[i] += random.random_gauss(0, 0.05);
				}
//	cout << neuron[i] << " ";
	
	
    }

//    update_neurons("HEBBIAN");

		for(int i = 0; i < net_size; i++){
				for(int j = 0; j < net_size; j++){
	  
						weight[i][j] += learning_rate * (neuron_buff[i]*neuron[j]);
//	  cout << weight[i][j] << endl;
//	  output_weight(i,j);

						if( weight_noise == true){
								weight[i][j] += 0.1*2*random.random_real() - 1;
						}

				}

		}


    for(int i = 0; i < net_size; i++){
				neuron[i] = neuron_buff[i];
    }



		double norm;
		for(int i = 0; i< net_size; i++){
				norm = 0;
				for(int j = 0; j < net_size; j++){
						norm += abs(weight[i][j]);
	  
				}

				cout << norm << endl;

				for(int j = 0; j < net_size; j++){
						if(norm != 0 
							 && !isnan(norm)
							 && norm > 1.
								){

								weight[i][j] /= norm;
	     
						}
				}
		}
  
    delete[] neuron_buff;
    delete[] weight_buff;
}



